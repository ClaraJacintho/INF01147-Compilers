// ----------------------------- 3.1 Declaracoes de Variaveis Globais -----------------------------
// As variaveis sao declaradas pelo tipo seguido de uma lista
// composta de pelo menos um nome de variavel (identifica-
// dor) separadas por virgula. Variaveis podem ser dos tipos primitivos 
//int, float, char, bool e string. As declaracoes de
//variaveis globais sao terminadas por ponto-e-vırgula, 
//e nao podem receber valores de inicializacao

int clara;
float clara, clara2;
bool fish, chips, vinegar;

//O tipo pode estar precedido opcionalmente pela palavra reservada static.

static int foo;
static bool foo, bar;

// A linguagem inclui tambem a declaracao de vetores, feita pela definicao
// de seu tamanho inteiro positivo entre colchetes, colocada
// a direita do nome.
static int clara[9];
bool clara[6], clara;
string foo, bar[7];

// ----------------------------- 3.2 Definicao de Funcoes -----------------------------
// Cada funcao e definida por um cabecalho e um corpo, sendo
// que esta definicao nao e terminada por ponto-e-vırgula. O
// cabecalho consiste no tipo do valor de retorno, que nao pode
// ser vetor, seguido pelo nome da funcao e terminado por uma
// lista. A lista e dada entre parenteses e e composta por zero
// ou mais parametros de entrada, separados por vırgula.

bool foo(){}
int clara(int lista){}
char tot(int a, bool b, char c){}

//O tipo pode estar precedido opcionalmente pela palavra reservada static. 
static bool a(){}
bool c(static int clara){};

//Cada parametro e definido pelo seu tipo e nome, e nao pode ser do tipo vetor.
// O tipo de um parametro pode ser opcionalmente precedido da palavra 
// reservada const. 

bool copo(int a, bool b, char c){};
bool faca(const int bool, const int c){};
string faca(static int a, static const int b, int c){};

// O corpo da funcao e um bloco de comandos.
int a(){ a << 2; input clara; output 5; }

// ----------------------------- 3.3 Bloco de Comandos -----------------------------
// Um bloco de comandos e definido entre chaves, e consiste
// em uma sequencia, possivelmente vazia, de comandos
// simples cada um terminado por ponto-e-vırgula. 
int a(){}
int a(){
    clara >> 5;
    return clara;
    break;
    continue;
}

// Um bloco de comandos e considerado como um comando unico 
// simples, recursivamente, e pode ser utilizado em qualquer
// construc¸ao que aceite um comando simples. 
int a(){{{{{{{};};};};};};}

int main(){
/* ----------------------------- 3.4 Comandos Simples -----------------------------
Os comandos simples da linguagem podem ser: declaracao
de variavel local, atribuic¸ ´ ao, construcoes de fluxo de controle, 
operacoes de entrada, de saıda, e de retorno, um bloco de comandos, 
e chamadas de funcao. */

// ~~~~~~~~ Declaracao de Variavel ~~~~~~~~
// Consiste no tipo da variavel precedido opcionalmente pela
// palavra reservada static, seguido de uma lista composta
// de pelo menos um nome de variavel (identificador) sepa-
// radas por vırgula. Os tipos podem ser aqueles descritos
// na sec¸ao sobre variaveis globais.

int a;
float a,b, c;
static char a;
static string a, b, c;

// As declaracoes locais, ao contrario das globais, nao permitem vetores 
// e podem permitir o uso da palavra reservada const antes do tipo (apos a 
// palavra reservada static caso esta aparecer). 
// Uma variavel local pode ser opcionalmente inicializada com um valor
// valido caso sua declarac ao seja seguida do operador com- ˜
// posto <= e de um identificador ou literal.

int a <= identificador;
int a, b <= identificador, c;
int a <= 1, b <= a, c <= true, d <= "string", e <= 'e', f <= false;

// ~~~~~~~~ Comando de Atribuicao ~~~~~~~~
// Existe apenas uma forma de atribuicao para identificadores.
// Identificadores podem receber valores assim (primeiro caso
// de um identificador simples; segundo caso de um identificador que e um vetor): ´
// identificador = expressao

clara = ?coisa : print(baby_shark) : print(do_do_do_do);

// identificador[expressao] = expressao
clara[4] = 5+-5
clara[45+-0+(8^(true))] = #clara

// ~~~~~~~~ Comandos de Entrada e Saıda ~~~~~~~~
// Para entrada de dados, o comando tem a palavra reservada
// input, seguida de um identificador.
input clara;

// O comando de saıda e identificado pela palavra reservada
// output, seguida de um identificador ou de um literal.
output clara;
output true;
output "clara";

// ~~~~~~~~ Chamada de Funcao ~~~~~~~~
// Uma chamada de funcao consiste no nome da funcao,
// seguida de argumentos entre parenteses separados por
// vırgula. Um argumento pode ser uma expressao.
nome_da_funcao();
nome(5+5, clara);

// ~~~~~~~~ Comandos de Shift ~~~~~~~~
// Sendo numero um literal inteiro positivo, temos os exem- 
// plos validos abaixo. Os exemplos sao dados com  <<, mas
// as entradas sao sintaticamente validas tambem para >>. O
// numero deve ser representado por um literal inteiro.
// identificador << numero
clara << 4;

// identificador[express˜ao] << numero
clara[5+5*(6)] << 4;

// ~~~~~~~~ Comando de Retorno, Break, Continue ~~~~~~~~
// Retorno e a palavra reservada return seguida de uma expressao.
return clara;
return 5+(5)
// Os comandos break e continue sao simples. 
break;
continue;

// ~~~~~~~~ Comandos de Controle de Fluxo ~~~~~~~~
//  Em todas as construcoes de controle de fluxo, o termo  bloco
// indica um bloco de comandos. Este nao tem ponto-e-vırgula
// nestas situacoes

// A linguagem possui construcoes condicionais, iterativas e de 
// selecao para controle estruturado de fluxo. As condicionais 
// incluem o if com o else opcional, assim:
// if (expressao) bloco
if (clara) {}
if (clara) {return 5*+5};

//if (expressao) bloco else bloco
if(false){}else{}
if(true){input clara;}else{}
if(5){}else{printf();}
if(clara){output 5;}else{clara << 2;}

// As construcoes iterativas sao as seguintes no formato:
// Os dois marcadores atrib do comando for representa
// o comando de atribuicao,  unico aceito nestas posicoes.
// for (atrib: expressao: atrib) bloco
for(i = 0 : i<n : i = i+1){}
for(i = false||true : i>=43 : i = ?i+#1){print(shark);}

//while (expressao) do bloco
while(true) do {}
while(baby) do {cry();}


// ----------------------------- 3.5 Expr. Aritmeticas, Logicas -----------------------------
// As expressoes podem ser de dois tipos: aritmeticas e logicas. 
// As expressoes aritmeticas podem ter como operandos:  ´
// (a) identificadores, opcionalmente seguidos de expressao in-
//teira entre colchetes, para acesso a vetores; 
clara = identificador;
clara = clara[identificador];

// (b) literais numericos como inteiro e ponto-flutuante;
clara = 5;
clara = 5.5;
clara = 5.5e5;

// (c) chamada de funcao. 
clara = print();
clara = print(5);

//As expressoes aritmeticas podem ser formadas re- ´
// cursivamente com operadores aritmeticos, assim como per- ´
// mitem o uso de parenteses para forcar uma associatividade ˆ
// ou precedencia diferente daquela tradicional. A associativi- ˆ
// dade e a esquerda. 

clara = 5 + 6 * 7 - +clara[identificador] *-6/clara%43
clara = (45+7)*7

// Expressoes logicas podem ser formadas atraves dos ope-
// radores relacionais aplicados a expressoes aritmeticas, 
clara = 5+5 ||5*6

// ou de operadores logicos aplicados a expressoes logicas, recursi- 
// vamente. Outras expressoes podem ser formadas conside-
// rando variaveis logicas do tipo bool. A descricao sintatica 
// deve aceitar qualquer operadores e subexpressao de um des- 
// ses tipos como validos, deixando para a analise semantica
// das proximas etapas do projeto a tarefa de verificar a vali-
// dade dos operandos e operadores.

// Unarios (todos prefixados)
// + sinal positivo explıcito
clara = + 4

// - inverte o sinal
clara = - 4

// ! negacao logica
clara = !clara

// & acesso ao endereco da variavel
clara = &clara

// * acesso ao valor do ponteiro
clara = *clara

// ? avalia uma expressao para true ou false
clara = ?clara

// # acesso a um identificador como uma tabela hash
clara = #clara



}